package org.transport;

import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import org.apache.commons.io.FileUtils;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.gradle.api.Project;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;
import java.util.stream.Stream;

public final class Generator {

	private static final Logger LOGGER = LogManager.getLogger(Generator.class);

	public static void generate(Project project) {
		iterateFolder(project.getRootDir().toPath().resolve("buildSrc/src/main/resources/schema"), path -> {
			try {
				final String className = capitalizeFirstLetter(path.getFileName().toString().split("\\.")[0]);
				final StringBuilder stringBuilderMain = new StringBuilder("package org.transport.generated;import jakarta.annotation.*;import jakarta.persistence.*;import lombok.Getter;import org.transport.type.*;\n");
				stringBuilderMain.append(String.format("@Entity@Getter public final class %s{\n", className));
				final StringBuilder stringBuilderFields = new StringBuilder();
				final StringBuilder stringBuilderConstructor1 = new StringBuilder(); // public, default constructor
				final StringBuilder stringBuilderConstructor2 = new StringBuilder(); // package private, ID only
				final StringBuilder stringBuilderConstructor3 = new StringBuilder(); // private, all fields
				final StringBuilder stringBuilderDTOFields = new StringBuilder();
				final List<String> parameters = new ArrayList<>();
				final List<String> dtoConvert = new ArrayList<>();
				final List<JsonObject> content = JsonParser.parseString(FileUtils.readFileToString(path.toFile(), StandardCharsets.UTF_8)).getAsJsonArray().asList().stream().map(JsonElement::getAsJsonObject).toList();

				for (int i = 0; i < content.size(); i++) {
					try {
						final JsonObject jsonObject = content.get(i);
						final String name = jsonObject.get("name").getAsString();
						final boolean autoGeneratedId = name.isEmpty();

						if (i == 0) {
							if (autoGeneratedId) {
								stringBuilderFields.append("\t@Id@Nonnull@GeneratedValue(strategy=GenerationType.SEQUENCE,generator=\"seqGen\")@SequenceGenerator(name=\"seqGen\",sequenceName=\"id_seq\",allocationSize=1)\n\tprivate final long id;\n");
								stringBuilderConstructor1.append("\t\tthis.id=0;\n");
								stringBuilderConstructor2.append(String.format("\t%s(long id){\n", className)).append("\t\tthis.id=id;\n");
								stringBuilderConstructor3.append("\t\tthis.id=id;\n");
								stringBuilderDTOFields.append("\t\tpublic long id;\n");
								parameters.add("long id");
								dtoConvert.add("id");
							} else {
								stringBuilderFields.append(String.format("\t@Id@Nonnull\n\tprivate final String %s;\n", name));
								stringBuilderConstructor1.append(String.format("\t\tthis.%s=\"\";\n", name));
								stringBuilderConstructor2.append(String.format("\t%s(String %s){\n", className, name)).append(String.format("\t\tthis.%s=%s;\n", name, name));
								stringBuilderConstructor3.append(String.format("\t\tthis.%s=%s;\n", name, name));
								stringBuilderDTOFields.append(String.format("\t\tpublic String %s;\n", name));
								parameters.add(String.format("String %s", name));
								dtoConvert.add(String.format("convertId(sourceIndex,%s)", name));
							}
						} else {
							final String type = getStringOrNull(jsonObject, "type");
							final String enumType = getStringOrNull(jsonObject, "enum");
							final String referenceType = getStringOrNull(jsonObject, "reference");
							final String actualType = referenceType == null ? type == null ? enumType : type : referenceType;
							final String defaultValue = getStringOrNull(jsonObject, "default");
							final int length = getInteger(jsonObject, "length");
							stringBuilderConstructor1.append(String.format("\t\tthis.%s=%s;\n", name, defaultValue));
							stringBuilderConstructor2.append(String.format("\t\tthis.%s=%s;\n", name, defaultValue));
							stringBuilderConstructor3.append(String.format("\t\tthis.%s=%s;\n", name, name));

							if (referenceType == null) {
								stringBuilderFields.append(String.format("\t%s@Column(nullable=%s%s)%s%s\n", enumType == null ? "" : "@Enumerated(EnumType.STRING)", defaultValue == null, length > 0 ? ",length=" + length : "", defaultValue == null ? "@Nullable" : "@Nonnull", "Time".equals(actualType) || "Date".equals(actualType) ? String.format("@Convert(converter=%s.Converter.class)", actualType) : ""));
								stringBuilderDTOFields.append(String.format("\t\tpublic %s %s;\n", actualType, name));
								dtoConvert.add(defaultValue == null || actualType != null && Character.isLowerCase(actualType.charAt(0)) ? name : String.format("%s==null?%s:%s", name, defaultValue, name));
							} else {
								stringBuilderFields.append(String.format("\t@ManyToOne@JoinColumn(nullable=%s,name=\"%s\")%s\n", defaultValue == null, name, defaultValue == null ? "@Nullable" : "@Nonnull"));
								stringBuilderDTOFields.append(String.format("\t\tpublic String %s;\n", name));
								dtoConvert.add(String.format("%snew %s(convertId(sourceIndex,%s))", defaultValue == null ? String.format("!org.springframework.util.StringUtils.hasText(%s)?null:", name) : "", actualType, name));
							}

							stringBuilderFields.append(String.format("\tprivate final %s %s;\n", actualType, name));
							parameters.add(String.format("%s %s", actualType, name));
						}
					} catch (Exception e) {
						LOGGER.error("", e);
					}
				}

				stringBuilderMain.append(stringBuilderFields);
				stringBuilderMain.append(String.format("\tpublic %s(){\n", className)).append(stringBuilderConstructor1).append("\t}\n");
				stringBuilderMain.append(stringBuilderConstructor2).append("\t}\n");
				stringBuilderMain.append(String.format("\tprivate %s(%s){\n", className, String.join(",", parameters))).append(stringBuilderConstructor3).append("\t}\n");
				stringBuilderMain.append(String.format("\tpublic static final class %sDTO extends DTOBase<%s>{\n", className, className));
				stringBuilderMain.append(stringBuilderDTOFields);
				stringBuilderMain.append(String.format("\t\tpublic %s convert(int sourceIndex){\n", className)).append(String.format("\t\t\treturn new %s(%s);\n", className, String.join(",", dtoConvert))).append("\t\t}\n");
				stringBuilderMain.append("\t}\n").append("}");
				FileUtils.write(project.getRootDir().toPath().resolve("src/main/java/org/transport/generated").resolve(className + ".java").toFile(), stringBuilderMain.toString(), StandardCharsets.UTF_8);
			} catch (IOException e) {
				LOGGER.error("", e);
			}
		});

	}

	private static void iterateFolder(Path path, Consumer<Path> callback) {
		try (final Stream<Path> schemasStream = Files.list(path)) {
			schemasStream.forEach(callback);
		} catch (IOException e) {
			LOGGER.error("", e);
		}
	}

	private static String getStringOrNull(JsonObject jsonObject, String key) {
		return jsonObject.has(key) ? jsonObject.get(key).getAsString() : null;
	}

	private static int getInteger(JsonObject jsonObject, String key) {
		return jsonObject.has(key) ? jsonObject.get(key).getAsInt() : -1;
	}

	private static String capitalizeFirstLetter(String text) {
		return text.isEmpty() ? "" : text.substring(0, 1).toUpperCase() + text.substring(1);
	}
}
